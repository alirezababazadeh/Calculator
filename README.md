# ماشین حساب
این پروژه یک ماشین حساب ساده بدون رابط کاربری و تحت خط فرمان ایجاد شده است و هدف آن، انجام دستورات و نیازمندی‌های موجود در آزمایش اول درس آز مهندسی نرم‌افزار است. این پروژه به زبان جاوا زده شده است.
مطابق نیازمندی‌ها حداقل 15 کامیت در این پروژه قرار دارد. عمل push بر روی master تنها به وسیله pull request ممکن است و امکان merge وجود ندارد. برای هر فیچر یک branch ایجاد شده است. همچنین branch های دیگه‌ای مانند wip
و bug در بین انها وجود دارد. همچنین کامیت‌ها از قاعده Type: description پیروی می‌کنند و نام برنچ ها از قاعده authorname-type-name پیروی می‌کند. حداقل 2 کانفلیکت نیز در پروژه برطرف شده است.

## سوالات
سوال 1 : 
<br>

پوشه `.git` جایی است که گیت در آن متادیتا و دیتابیس اشیا را برای پروژه ما ذخیره می‌کند. این یکی از مهم ترین پارت‌های گیت است و وقتی شما پروژه را کلون کنید درون کامپیوتر شما میاید. با استفاده از دستور git init ساخته می شود 
<br>

سوال 2 :
<br>

اتمیک بودن کامیت به این معناست که شما می‌توانید از آن کامیت برگردید بدون آن که اثرات جانبی بد و پشیمانی‌ای به وجود آید. اگر یک کامیت از  تاریخچه کامیت‌های شما پاک شود ولی باعث شود تغییرات درست دیگر شما در پروزه پاک شود، آن کامیت اتمیک نبوده.
<br>
در گیت شما با `pull request` به بقیه می‌گویید که این سری تغییرات را در branchی جدا شما داده‌اید و اگر مورد تایید شما هست با برنامه اصلی ترکیب کنید.

<br>
<br>

سوال 3 :
<br>

در گیت `git fetch` آپدیت‌های داخل کد را دریافت می‌کند ولی با کد اصلی ادغام نمی‌کند در حالی که اگر بخواهیم این تغییرات در ریپازیتوری اعمال شود باید `merge` کنیم اما `git pull` به صورت مستقیم یک `git fetch` انجام داده و سپس `merge` می‌کند و لازم نیست ما هر کار را جدا انجام دهیم. 
<br>

<br>
برای مثال اگر می‌خواید بدانید بقیه روی کد چیکار کردند ولی نمی‌خواهید فعلا کد خود که در حال توسعه‌اش هستید را دست بزنید می‌توانید از `git fetch` استفاده کنید ولی اگر کارتان تمام شده می‌توانید به صورت مستقیم از `git pull` استفاده کنید.
<br>
<br>

اما `git rebase` کاری می‌کند که هر کامیتی که شما در برنچ فعلی خود دارید ولی در upstream نیست در فضای موقتی ذخیره شود تا برنچ شما همانند قبل این که تغییرات خود را شروع کنید شود. برای مثال از استفاده نیز اگر شما دستور `git pull -rebase` را بزنید، گیت تغییرات ریموت را می‌گیرد و تغییرات لوکال شما را عقب می‌برد و بعد از اضافه کردن تغییرات ریموت تغییرات شما را یکی یکی روی برنچ آپدیت شده میاورد. این مورد اگر کار در حال توسعه شما نیازی داشته باشد که دیگری توسعه داده خیلی به درد بخور است و می‌توان ازش استفاده کرد. 
<br>
<br>
سوال 4 : 
<br>
با دستور `git reset` ما می‌توانیم در برنچی که هستیم با حذف کامیت ها به کامیت های قبلی برگردیم. برای مثال با دستور `git checkout new-feature reset HEAD~2` اگر در برنچ `new-feature` ما 3 کامیت داشته باشیم با این دستور می‌توانیم به کامیت اول برگردیم و 2 کامیت قبلی را حذف کنیم.
<br> 
برخلاف دستور `git reset` که ما ممکن است در برنچی بعد از کامیت‌های `A` و `B` و `C` به این نتیجه برسیم که کامیتی که در قسمت `B` انجام دادیم باعث باگ شده یا تغییراتی را اضافه کرده که ما ‌نمی‌خواستیم؛ بنابرین ما می‌توانیم با دستور `git revert B` کاری کنیم که گیت تغییرات انجام شده در قسمت کامیت `B` را با نگه داشتن حداکثری کامیت `C` به ما برگرداند و درواقع کاری که می‌کند کامیت جدیدی مثلا به نام `B*` تولید می‌شود (بعد از کامیت `C`) که در این کامیت تغییرات `B` از بین رفته‌اند.

سوال 5 : 
<br>





